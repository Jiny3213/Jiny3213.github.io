<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>常见排序算法的js实现 | Jiny3213的个人博客</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.1.1"></head><body><header><nav><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><div id="post-info"><span>date:<time datetime="2021-03-18T08:37:00.000Z" id="date"> 2021-03-18</time></span><br><span>updated:<time datetime="2021-03-26T02:40:45.268Z" id="updated"> 2021-03-26</time></span></div><h1>常见排序算法的js实现</h1><hr></div><div id="post-content"><h2 id="js自带的排序方法-Array-prototype-sort-compareFunction"><a href="#js自带的排序方法-Array-prototype-sort-compareFunction" class="headerlink" title="js自带的排序方法 Array.prototype.sort(compareFunction)"></a>js自带的排序方法 Array.prototype.sort(compareFunction)</h2><blockquote>
<p>MDN 文档 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort</a><br>关于浏览器排序实现相关文章推荐 <a target="_blank" rel="noopener" href="https://efe.baidu.com/blog/talk-about-sort-in-front-end/">https://efe.baidu.com/blog/talk-about-sort-in-front-end/</a></p>
</blockquote>
<p>这个方法会把数字转换为字符串再按照字典顺序进行比较, 传入一个函数可以改变其行为</p>
<p>compareFunction 接受两个参数, 表示进行比较的前一项和后一项, 返回一个数字, 用 ts 表示为 <code>fn(a: any, b: any): number</code></p>
<p>若返回的数字大于0, 则第一个项排在第二个项后面; 其余情况(包括0), 第一个项排在第一个项前面</p>
<p>注意: 这个方法排序产生的结果是不稳定的, 内部实现方式也根据浏览器不同而有所差异</p>
<blockquote>
<p>v8 源码中, 在数组长度较小时使用插入排序(稳定), 其余情况使用快速排序(不稳定) <a target="_blank" rel="noopener" href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js">https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 711 行</span><br><span class="hljs-comment">// In-place QuickSort algorithm.</span><br><span class="hljs-comment">// For short (length &lt;= 22) arrays, insertion sort is used for efficiency.</span><br><br><span class="hljs-comment">// 763 行</span><br><span class="hljs-comment">// Insertion sort is faster for short arrays.</span><br>  <span class="hljs-keyword">if</span> (to - <span class="hljs-keyword">from</span> &lt;= <span class="hljs-number">10</span>) &#123;<br>    InsertionSort(a, <span class="hljs-keyword">from</span>, to);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 正序排列</span><br><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1111</span>, <span class="hljs-number">111</span>, <span class="hljs-number">11</span>]<br>array.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b) <span class="hljs-comment">// 倒序时返回 b - a</span><br><span class="hljs-built_in">console</span>.log(array) <span class="hljs-comment">// [11, 111, 1111]</span><br></code></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>时间复杂度 O(n) - O(n²), 稳定, 原地</p>
<p>按顺序比较每两个项, 若前一项大于后一项则交换这两个项, 最小的项最终会”冒泡”到最前面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>      <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">let</span> temp = arr[j+<span class="hljs-number">1</span>]<br>        arr[j+<span class="hljs-number">1</span>] = arr[j]<br>        arr[j] = temp<br>      &#125; <br>    &#125; <br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>时间复杂度 O(n²), 不稳定, 原地</p>
<p>从未排序的序列中找到最小的元素, 放在序列的起始位置, 重复这个过程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> minIndex, temp<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    minIndex = i<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i+<span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>      <span class="hljs-keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;<br>        minIndex = j<br>      &#125;<br>    &#125;<br>    temp = arr[minIndex]<br>    arr[minIndex] = arr[i]<br>    arr[i] = temp<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>时间复杂度 O(n) - O(n²), 稳定, 原地</p>
<p>将第一个元素看作有序序列, 将后面的元素依次插入到前面的合适的位置形成新的有序序列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> preIndex, current<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>    preIndex = i - <span class="hljs-number">1</span><br>    current = arr[i] <span class="hljs-comment">// 抽取一个数</span><br>    <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>      arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex] <span class="hljs-comment">// 往前移</span><br>      preIndex--<br>    &#125;<br>    arr[preIndex + <span class="hljs-number">1</span>] = current <span class="hljs-comment">// 插回去</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是对插入排序的优化, 时间复杂度 O(nLogn), 不稳定, 原地</p>
<p>希尔排序先将序列按一定的步长分割成若干子序列进行插入排序, 再逐步缩减步长到1, 步长为1时即为一次插入排序; 希尔排序比插入排序每次循环只能移动一个元素相比, 效率得到了很大的提升 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 3个 for 一个 if</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>); d &gt; <span class="hljs-number">0</span>; d = <span class="hljs-built_in">Math</span>.floor(d / <span class="hljs-number">2</span>)) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = d; i &lt; arr.length; i++) &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i - d; j &gt;= <span class="hljs-number">0</span>; j -= d) &#123;<br>        <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + d]) &#123;<br>          <span class="hljs-keyword">let</span> temp = arr[j + d]<br>          arr[j + d] = arr[j]<br>          arr[j] = temp<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>时间O(nlogn), 空间O(n), 稳定</p>
<p>归并排序采用分治法, 利用了额外的空间, 比较两个有序的数组并依次选出最小的数, 合并成一个有序的数组, 通过递归把”有序数组”缩小到只有一个元素的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 自上而下的递归, 3个 while</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr<br>  <span class="hljs-keyword">let</span> middle = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>),<br>  left = arr.slice(<span class="hljs-number">0</span>, middle),<br>  right = arr.slice(middle)<br>  <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">left, right</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> result = [] <span class="hljs-comment">// 额外空间</span><br>  <span class="hljs-keyword">while</span>(left.length &amp;&amp; right.length) &#123;<br>    <span class="hljs-keyword">if</span>(left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]) &#123;<br>      result.push(left.shift())<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.push(right.shift())<br>    &#125; <br>  &#125;<br>  <span class="hljs-keyword">while</span>(left.length) &#123;<br>    result.push(left.shift())<br>  &#125;<br>  <span class="hljs-keyword">while</span>(right.length) &#123;<br>    result.push(right.shift())<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-comment">// 自下而上的迭代, 利用for循环取代递归</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iterativeMergeSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> step = <span class="hljs-number">1</span>; step &lt; arr.length * <span class="hljs-number">2</span>; step *= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>; left + step &lt; arr.length; left += step * <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// left + step &gt;= arr.length 时只有左数组, 没有归并的必要</span><br>      <span class="hljs-keyword">let</span> right = left + step<br>      <span class="hljs-keyword">let</span> arrLeft = arr.slice(left, right), <span class="hljs-comment">// 左数组</span><br>      arrRight<br>      <span class="hljs-comment">// 右数组凑不够, 或刚刚够</span><br>      <span class="hljs-keyword">if</span>(right + step &gt;= arr.length) &#123; <br>        arrRight = arr.slice(right)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        arrRight = arr.slice(right, right + step) <span class="hljs-comment">// 右数组</span><br>      &#125;<br>      <span class="hljs-keyword">let</span> current = left<br>      <span class="hljs-keyword">while</span>(arrLeft.length &amp;&amp; arrRight.length) &#123;<br>        <span class="hljs-keyword">if</span>(arrLeft[<span class="hljs-number">0</span>] &lt;= arrRight[<span class="hljs-number">0</span>]) &#123;<br>          arr[current++] = arrLeft.shift()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          arr[current++] = arrRight.shift()<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">while</span>(arrLeft.length) &#123;<br>        arr[current++] = arrLeft.shift()<br>      &#125;<br>      <span class="hljs-keyword">while</span>(arrRight.length) &#123;<br>        arr[current++] = arrRight.shift()<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>时间nlogn - n², 空间logn, 原地, 不稳定</p>
<p>快速排序同样采用分治法, 根据一个基准值, 把一个数组分成两个, 比基准值大的和比基准值小的, 再递归地执行这个过程; 它的特点如其名, 平均效率最高</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr, left, right</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> partitionIndex<br>  left = <span class="hljs-keyword">typeof</span> left === <span class="hljs-string">&#x27;number&#x27;</span> ? left : <span class="hljs-number">0</span> <span class="hljs-comment">// 初始只传入一个 arr</span><br>  right = <span class="hljs-keyword">typeof</span> right === <span class="hljs-string">&#x27;number&#x27;</span> ? right : arr.length - <span class="hljs-number">1</span><br>  <br>  <span class="hljs-keyword">if</span>(left &lt; right) &#123; <br>    partitionIndex = partition(arr, left, right) <span class="hljs-comment">// 分组, 获取中间的基准值, 左边的比基准值小, 右边的比基准值大</span><br>    quickSort(arr, left, partitionIndex - <span class="hljs-number">1</span>) <span class="hljs-comment">// 快排左数组</span><br>    quickSort(arr, partitionIndex + <span class="hljs-number">1</span>, right) <span class="hljs-comment">// 快排右数组</span><br>  &#125; <span class="hljs-comment">// 其他情况说明已经切分到最小单位了, 直接返回</span><br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr, left, right</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> pivot = left, <span class="hljs-comment">// 基准</span><br>  index = pivot + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = index; i &lt;= right; i++) &#123;<br>    <span class="hljs-keyword">if</span>(arr[i] &lt; arr[pivot]) &#123;<br>      swap(arr, i, index) <span class="hljs-comment">// 把较小数放在基准数的后面</span><br>      index ++ <span class="hljs-comment">// index 前移, 避开刚才置换过来的较小数      </span><br>    &#125;<br>  &#125;<br>  swap(arr, pivot, index - <span class="hljs-number">1</span>) <span class="hljs-comment">// 基准数与最后被置换的较小数交换位置, 这样基准数左边的数都比基准数小</span><br>  <span class="hljs-keyword">return</span> index - <span class="hljs-number">1</span> <span class="hljs-comment">// 返回基准数当前的位置</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">arr, i, j</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> temp = arr[i]<br>  arr[i] = arr[j]<br>  arr[j] = temp<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>时间复杂度nlogn, 原地, 不稳定</p>
<p>堆排序是利用堆这种数据结构, 把数组理解成一个完全二叉树, 把这棵完全二叉树做成大顶堆(父节点的值大于等于子节点的值); 交换堆顶的数和堆尾的数(把最大的数放到了最后面); 无视最后一个数(认为数组长度-1), 对堆顶进行一次大顶堆的调整, 重复上面两个过程直到数组长度为1</p>
<p>数组就会从堆尾开始变得有序, 大顶堆的话就会排列成递增的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 初始化建立大顶堆</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildMaxHeap</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 从有叶节点的节点开始进行堆调整, length / 2 正好是最后一个有叶节点的节点</span><br>    heapify(arr, i, arr.length)<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br><br><span class="hljs-comment">// 堆调整</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">arr, i, len</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>, <span class="hljs-comment">// 左儿子</span><br>  right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>, <span class="hljs-comment">// 右儿子</span><br>  largest = i<br>  <br>  <span class="hljs-keyword">if</span>(left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;<br>    largest = left<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;<br>    largest = right<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span>(largest !== i) &#123;<br>    swap(arr, i, largest)<br>    heapify(arr, largest, len)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">arr, i, j</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> temp = arr[j]<br>  arr[j] = arr[i]<br>  arr[i] = temp<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  arr = buildMaxHeap(arr)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>    swap(arr, <span class="hljs-number">0</span>, i) <span class="hljs-comment">// 交换堆顶和堆尾</span><br>    heapify(arr, <span class="hljs-number">0</span>, i) <span class="hljs-comment">// 调整堆顶</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>具有线性时间复杂度, 但要求输入的数据是有确定范围的整数(0 - k), 局限性较大; 以最大的整数+1为总长度创建一个数组(具有0-k下标的数组), 用数组的下标为输入的整数进行计数, 每有一个数k就对下标为k的元素+1, 最终从小到大把数重新列出来; 因此会消耗大量空间</p>
<p>计数排序的时间复杂度为 n+k, 空间复杂度为 O(k), 是稳定的排序算法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countingSort</span>(<span class="hljs-params">arr, maxValue</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(maxValue + <span class="hljs-number">1</span>),<br>  sortedIndex = <span class="hljs-number">0</span>,<br>  arrLen = arr.length,<br>  bucketLen = maxValue + <span class="hljs-number">1</span><br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrLen; i++) &#123;<br>    <span class="hljs-keyword">if</span>(!bucket[arr[i]]) &#123;<br>      bucket[arr[i]] = <span class="hljs-number">0</span><br>    &#125;<br>    bucket[arr[i]]++ <span class="hljs-comment">// 记录下这个数有多少个</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; bucketLen; j++) &#123;<br>    <span class="hljs-keyword">while</span>(bucket[j] &gt; <span class="hljs-number">0</span>) &#123;<br>      arr[sortedIndex++] = j<br>      bucket[j]--<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>是计数排序的优化版本, 用一个桶(可以装多个元素)取代计数排序中的一个萝卜一个坑的计数方式, 比如0-9放在第一个桶中, 10-19放在第二个桶中, 对每个桶进行分别排序, 再合并, 是否快速关键在于元素能否均匀地分配到各个桶中, 分配的越均匀, 效率越高</p>
<p>设有 k 个桶, 则平均时间复杂度为 n + k, 但最坏的情况(所有数都集中在一个桶中)时间复杂度达到 n², 是稳定的排序算法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bucketSort</span>(<span class="hljs-params">arr, bucketSize = <span class="hljs-number">5</span></span>) </span>&#123; <span class="hljs-comment">// bucketSize: 每个桶里面装多少个数据 </span><br>  <span class="hljs-keyword">if</span>(!arr.length) <span class="hljs-keyword">return</span> arr<br>  <span class="hljs-comment">// 找到数组中的最小值和最大值</span><br>  <span class="hljs-keyword">let</span> min = arr[<span class="hljs-number">0</span>], max = arr[<span class="hljs-number">0</span>]<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span>(arr[i] &lt; min) min = arr[i]<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i] &gt; max) max = arr[i]<br>  &#125;<br>  <br>  <span class="hljs-comment">// 初始化桶</span><br>  <span class="hljs-keyword">let</span> bucketCount = <span class="hljs-built_in">Math</span>.floor((max - min) / bucketSize) + <span class="hljs-number">1</span> <span class="hljs-comment">// 有多少个桶</span><br>  <span class="hljs-keyword">let</span> buckets = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(bucketCount)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buckets.length; i++) &#123;<br>    buckets[i] = []<br>  &#125;<br>  <span class="hljs-comment">// 分配元素到各个桶中</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    buckets[<span class="hljs-built_in">Math</span>.floor(<br>      (arr[i] - min) / bucketSize<br>    )].push(arr[i]) <span class="hljs-comment">// 分配到桶中</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> resultArr = []<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buckets.length; i++) &#123;<br>    insertionSort(buckets[i]) <span class="hljs-comment">// 对每个桶进行排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; buckets[i].length; j++) &#123; <span class="hljs-comment">// 排序之后就可以直接插入</span><br>      resultArr.push(buckets[i][j])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> resultArr<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>将整数按位切割成不同的数字, 然后按每个位数分别比较, 设 k 是整数的位数, 时间复杂度为 kn, 稳定的排序方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">radixSort</span>(<span class="hljs-params">arr, maxDigit</span>) </span>&#123; <span class="hljs-comment">// maxDigit: 最大位数</span><br>  <span class="hljs-keyword">let</span> counter = []<br>  <span class="hljs-keyword">let</span> mod = <span class="hljs-number">10</span>, dev = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++, dev *= <span class="hljs-number">10</span>, mod *= <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 按位循环: k</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123; <span class="hljs-comment">// 分配到桶里面: n</span><br>      <span class="hljs-keyword">let</span> bucket = <span class="hljs-built_in">parseInt</span>((arr[j] % mod) / dev)<br>      <span class="hljs-keyword">if</span>(counter[bucket] == <span class="hljs-literal">null</span>) &#123;<br>        counter[bucket] = []<br>      &#125;<br>      counter[bucket].push(arr[j])<br>    &#125;<br>    <span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; counter.length; j++) &#123; <span class="hljs-comment">// 写回数组</span><br>      <span class="hljs-keyword">if</span>(counter[j]) &#123;<br>        <span class="hljs-keyword">while</span>(counter[j].length) &#123;<br>          arr[pos++] = counter[j].shift()<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="示例数组"><a href="#示例数组" class="headerlink" title="示例数组"></a>示例数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</a></li>
<li>希尔排序 <a target="_blank" rel="noopener" href="https://www.runoob.com/data-structures/shell-sort.html">https://www.runoob.com/data-structures/shell-sort.html</a></li>
<li>希尔排序 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d730ae586cf3">https://www.jianshu.com/p/d730ae586cf3</a></li>
</ul>
<div id="paginator"></div></div><div id="post-footer"><hr><a href="/2021/02/01/vue2%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/">vue2高阶组件 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/"> Dr.Jiny</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">20</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">5</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">1</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E8%87%AA%E5%B8%A6%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95-Array-prototype-sort-compareFunction"><span class="toc-number">1.</span> <span class="toc-text">js自带的排序方法 Array.prototype.sort(compareFunction)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text">计数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text">桶排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">11.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%95%B0%E7%BB%84"><span class="toc-number">12.</span> <span class="toc-text">示例数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">13.</span> <span class="toc-text">参考文章</span></a></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">1970 to 2020</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>