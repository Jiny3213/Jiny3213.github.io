<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>使用uniapp在微信小程序中压缩图片 | Jiny3213 no blog</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.1.1"></head><body><header><nav><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><div id="post-info"><span>date:<time datetime="2020-09-30T06:05:48.000Z" id="date"> 2020-09-30</time></span><br><span>updated:<time datetime="2020-09-30T06:05:51.745Z" id="updated"> 2020-09-30</time></span></div><h1>使用uniapp在微信小程序中压缩图片</h1><hr></div><div id="post-content"><h2 id="问题产生的背景"><a href="#问题产生的背景" class="headerlink" title="问题产生的背景"></a>问题产生的背景</h2><p>需要用微信小程序收集用户的单据, 需要把图片转换为base64发送到服务器保存, 而且base64大小限制在256kb以下</p>
<h2 id="微信小程序压缩图片的常规方式"><a href="#微信小程序压缩图片的常规方式" class="headerlink" title="微信小程序压缩图片的常规方式"></a>微信小程序压缩图片的常规方式</h2><p>使用原生api, 在用户选择图片的过程中压缩, 通过去掉’original’选项强制用户选择压缩的图片, 而不允许选择原图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">wx.chooseImage(&#123;<br>  sizeType: [&#39;compressed&#39;, &#39;original&#39;],<br>  success: res &#x3D;&gt; &#123;<br>  &#x2F;&#x2F; ...<br>  &#125;   <br>&#125;)<br></code></pre></td></tr></table></figure>

<p>使用uniapp封装的api, <a target="_blank" rel="noopener" href="https://uniapp.dcloud.io/api/README?id=promise-%E5%B0%81%E8%A3%85">uniapp为大部分api封装了promise</a>, 通过then返回一个数组, 分别为错误对象和原始返回数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">uni.chooseImage(&#123;<br>  sizeType: [&#39;compressed&#39;, &#39;original&#39;],<br>&#125;).then(data &#x3D;&gt; &#123;<br>  let [err, res] &#x3D; data<br>  &#x2F;&#x2F; ...<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>这种方式虽然可以大大减少图片的体积到可用的范围, 常规图片可以压缩到70kb左右, 但图片严重失真, 用户的单据中的文字都无法看清!!</p>
<p>因此, 只能让用户上传原图再考虑压缩了</p>
<h2 id="使用canvas渲染图片进行压缩"><a href="#使用canvas渲染图片进行压缩" class="headerlink" title="使用canvas渲染图片进行压缩"></a>使用canvas渲染图片进行压缩</h2><p>在web端经常使用canvas来对图片进行裁剪, 压缩和转换, 但在小程序上有较多的限制, 但也不妨碍我们来尝试一下</p>
<p>考虑到上下文的强联系性和异步api, 因此以下均使用await方法</p>
<h3 id="canvas元素"><a href="#canvas元素" class="headerlink" title="canvas元素"></a>canvas元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;canvas<br>        canvas-id&#x3D;&#39;canvas&#39; <br>        id&#x3D;&quot;canvas&quot;<br>        :style&#x3D;&quot;&#123;width: canvasWidth + &#39;px&#39;, height: canvasHeight + &#39;px&#39;&#125;&quot;<br>        &gt;&lt;&#x2F;canvas&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>canvas-id 用于js获取canvas对象</li>
<li>style 通过内联样式动态改变canvas的宽高</li>
<li>除此之外, 还要在canvas外层罩一个view, 定位到屏幕外, 这样渲染的时候就不会被用户看到了</li>
</ul>
<h3 id="渲染canvas"><a href="#渲染canvas" class="headerlink" title="渲染canvas"></a>渲染canvas</h3><p>渲染前, 要先获取图片的长宽, 并动态修改canvas的宽高</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">await uni.getImageInfo(&#123;<br>  src: this.tmpFileList[0],<br>&#125;).then(res &#x3D;&gt; &#123;<br>  this.canvasWidth &#x3D; res[1].width<br>  this.canvasHeight &#x3D; res[1].height<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>获取到图片的长宽之后, 把图片渲染到canvas</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 渲染到canvas<br>const ctx &#x3D; uni.createCanvasContext(&#39;canvas&#39;, this)<br>ctx.drawImage(this.tmpFileList[0], 0, 0, this.canvasWidth, this.canvasHeight)<br> &#x2F;&#x2F; 这个api没有被封装为promise, 手动实现<br>await new Promise(resolve &#x3D;&gt; &#123;<br>  ctx.draw(false, () &#x3D;&gt; resolve())<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>压缩图片, 并生成临时文件路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">uni.canvasToTempFilePath(&#123;<br>  canvasId: &#39;canvas&#39;,<br>  x: 0,<br>  y: 0,<br>  width: this.canvasWidth,<br>  height: this.canvasHeight,<br>  destHeight: this.canvasHeight,<br>  destWidth: this.canvasWidth,<br>  quality: 0.5, &#x2F;&#x2F; 在这里调整图片的质量<br>  fileType: &#39;jpg&#39;,<br>&#125;, this)<br>.then(res &#x3D;&gt; &#123;<br>  res &#x3D; res[1]<br>  this.tmpFileList &#x3D; this.tmpFileList.concat(res.tempFilePath)<br>  console.log(&#39;压缩后的图片信息如下&#39;)<br>  this.filePathToBase64(res.tempFilePath)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>封装base64图片的方法, 可以在压缩前调用这个方法, 观察压缩前后base64大小的变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">filePathToBase64(filePath) &#123;<br>  let base64 &#x3D; wx.getFileSystemManager().readFileSync(filePath, &#39;base64&#39;)<br>  let beforeStr &#x3D; &#39;data:image&#x2F;jpeg;base64,&#39;<br>  console.log(&#96;base64的长度为$&#123;base64.length&#125;&#96;)<br>  return beforeStr + base64<br>&#125;,<br></code></pre></td></tr></table></figure>

<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>这个压缩方法在微信小程序模拟器上完美运行, 然而在手机上图片压缩后只剩图片的左上角, 也找不到问题出在哪, 所以搞了半天还是不能用, 怪就怪微信兼容性拉胯吧</p>
<div id="paginator"></div></div><div id="post-footer"><hr><a href="/2020/09/25/learn-git-8-fix-history/">重新认识git【九】改变历史提交 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/"> Dr.Jiny</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">16</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">4</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">1</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%A7%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">问题产生的背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%E7%9A%84%E5%B8%B8%E8%A7%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">微信小程序压缩图片的常规方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8canvas%E6%B8%B2%E6%9F%93%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E5%8E%8B%E7%BC%A9"><span class="toc-number">3.</span> <span class="toc-text">使用canvas渲染图片进行压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#canvas%E5%85%83%E7%B4%A0"><span class="toc-number">3.1.</span> <span class="toc-text">canvas元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93canvas"><span class="toc-number">3.2.</span> <span class="toc-text">渲染canvas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">3.3.</span> <span class="toc-text">结果</span></a></li></ol></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">1970 to 2020</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>